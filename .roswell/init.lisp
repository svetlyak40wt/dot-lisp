(in-package :cl-user)

;; #+sbcl
;; (sb-ext:restrict-compiler-policy 'debug 3)

;; Это включает ворнинги на несоответствие типов
;; для слотов классов, где указаны типы
;; #+sbcl
;; (sb-ext:restrict-compiler-policy 'safety 3)

#-sbcl
(declaim (optimize (debug 3) (safety 3)))


;; Загружается через Emacs
;; (pushnew "~/projects/lisp/sly-package-inferred/" asdf:*central-registry*
;;          :test #'equal)
;; (pushnew "~/projects/lisp/sly/slynk/" asdf:*central-registry*
;;          :test #'equal)

;; (let ((*debug-io* (make-broadcast-stream)))
;;   (ql:quickload :sly-package-inferred :silent t))

;; (sly-package-inferred/completion:install)


;;; Use CLPM with default configuration.
;;;
;;; Generated by CLPM 0.4.0-0.14+g2aa742a-dirty

#+lispworks
(setf system:*stack-overflow-behaviour* nil)

(require "asdf")

;; #-clpm-client
(defun load-clpm ()
  (when (asdf:find-system "clpm-client" nil)
    ;; Load the CLPM client if we can find it.
    (asdf:load-system "clpm-client")

    (let ((local-clpmfile (probe-file #P"clpmfile")))
      (when local-clpmfile
        (format t "Activating CLPM bunldle ~A~%"
                local-clpmfile)
        (uiop:symbol-call :clpm-client '#:activate-context
                          local-clpmfile)))

    (when (uiop:symbol-call :clpm-client '#:active-context)
      ;; If started inside a context (i.e., with `clpm exec` or `clpm bundle exec`),
      ;; activate ASDF integration
      (uiop:symbol-call :clpm-client '#:activate-asdf-integration))))

;; Autoactivates CLPM and bundle if clpmfile was found
;; (load-clpm)


;; TODO: подумать как бы вызывать эту функцию автоматически когда REPL стартует, но не вызывать, для собранного бинарника
(defun set-process-name (title)
  "Use command like this to see the name in the process list:

   ps -eo pid,psr,pcpu,pmem,rss,stat,comm,args
   or
   ps -o pid,psr,pcpu,pmem,rss,stat,comm,args -p 316476
  "
  (uiop:with-output-file (stream "/proc/self/comm" :if-exists :overwrite)
    (write-string title
                  stream)))


(handler-bind ((serious-condition
                (lambda (condition)
                  (uiop:print-condition-backtrace condition)
                  (uiop:quit 1))))
  (let ((fix-filename (merge-pathnames
                       (make-pathname :directory '(:relative ".quicklisp-client-fix")
                                      :name "quicklisp-fix"
                                      :type "lisp")
                       (user-homedir-pathname))))
    (let ((quicklisp-found #+quicklisp t
                           #-quicklisp nil))
      (cond
       ((not quicklisp-found)
        (warn "Quicklisp is not available, skipping fix loading.~%"))
       ((probe-file fix-filename)
        (handler-bind ((warning #'muffle-warning))
          (load fix-filename)))
       (t
        (warn "Quicklisp fix was not found at ~S.~%" fix-filename))))))
